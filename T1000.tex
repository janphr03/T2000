\documentclass[12pt,a4paper]{article} % Standard für Hausarbeiten

% Sprachunterst\"utzung f\"ur deutsche Umlaute und Silbentrennung
\usepackage[utf8]{inputenc}  % Zeichencodierung
\usepackage[T1]{fontenc}     % Korrekte Darstellung von Umlauten
\usepackage[ngerman]{babel}  % Deutsche Sprache und Silbentrennung
\usepackage{csquotes}

% Seitenr\"ander sch\"oner machen
\usepackage[a4paper, left=3cm, right=3cm, top=2.5cm, bottom=2.5cm]{geometry}

% Mathematik-Symbole
\usepackage{amsmath, amssymb}

% Grafiken und Bilder einf\"ugen
\usepackage{graphicx}  
\usepackage{float}      % Bessere Kontrolle \über die Platzierung

% Tabellen verbessern
\usepackage{array, booktabs}

% Literaturverzeichnis mit BibTeX
\usepackage[style=ieee, backend=biber]{biblatex}
\addbibresource{literature.bib}
\addbibresource{Meine Bibliothek.bib}

% Quellcode sch\"on darstellen
\usepackage{listings}
\usepackage{xcolor}

\usepackage{needspace} % in der Präambel

\usepackage[acronym]{glossaries}

\let\oldsection\section
\renewcommand{\section}{\clearpage\oldsection}


\newacronym{dll}{DLL}{Dynamic Linked Library -- eine zur Laufzeit ladbare Programmbibliothek}
\newacronym{mysql}{MySQL}{Open-Source-Datenbankmanagementsystem}
\newacronym{sql}{SQL}{Structured Query Language -- Sprache zur Verwaltung und Abfrage relationaler Datenbanken}
\newacronym{sqlException}{SQL-Exception}{Fehlermeldung, die beim Ausführen eines SQL-Befehls auftritt, z.\,B. bei Syntaxfehlern, Verbindungsproblemen oder Zugriffsverletzungen}
\newacronym{retryMechanism}{retry-Mechanism}{Automatischer Wiederholungsversuch bei fehlgeschlagenen Operationen, z.\,B. bei Netzwerkproblemen oder Datenbankzugriffen}
\newacronym{cs}{C\#}{Objektorientierte Programmiersprache auf der .NET-Plattform}
\newacronym{connPooling}{connection-Pooling}{Technik zur Wiederverwendung offener Datenbankverbindungen, um Verbindungsaufbauzeiten zu minimieren und Systemressourcen effizienter zu nutzen}
\newacronym{ciPipeline}{CI-Pipeline}{Continuous-Integration-Pipeline -- automatisierter Prozess zum Testen, Bauen und Verteilen von Software}
\newacronym{containerUmgebung}{Container-Umgebung}{Laufzeitumgebung, in der Anwendungen isoliert und reproduzierbar in Containern betrieben werden, z.\,B. mit Docker}
\newacronym{architekturpattern}{Architekturpattern}{Wiederverwendbares Lösungsmuster zur Strukturierung von Softwaresystemen auf höherer Abstraktionsebene}
\newacronym{redundanz}{Redundanz}{Mehrfache Ausführung oder Speicherung gleicher Funktionalitäten oder Daten, oft unerwünscht in Softwarearchitektur}
\newacronym{boilerplate}{Boilerplate-Code}{Wiederverwendbarer Standardcode, der oft unverändert in vielen Programmen vorkommt, z.\,B. zur Initialisierung oder Strukturierung}
\newacronym{mock}{Mock}{Platzhalter-Objekt, das in Tests reale Abhängigkeiten simuliert, um das Verhalten einzelner Komponenten isoliert zu prüfen}
\newacronym{logging}{Logging}{Protokollierung von Systemereignissen und Programmabläufen zur Fehlerdiagnose und Nachvollziehbarkeit}

\newacronym{oop}{OOP}{Objektorientierte Programmierung – ein Programmierparadigma, das auf den Konzepten von Klassen, Objekten, Vererbung, Polymorphie und Kapselung basiert. Es kombiniert Zustände und Funktionen innerhalb sogenannter Objekte, die über definierte Schnittstellen miteinander kommunizieren. Ziel ist die Strukturierung, Wiederverwendbarkeit und Wartbarkeit komplexer Softwaresysteme.}
\newacronym{oopObjekt}{Objekt}{Instanz einer Klasse, die Daten (Attribute) und Verhalten (Methoden) kapselt}
\newacronym{oopKlasse}{Klasse}{Bauplan für Objekte, der Attribute und Methoden definiert}
\newacronym{oopMethode}{Methode}{Funktion innerhalb einer Klasse, die das Verhalten eines Objekts beschreibt}
\newacronym{oopVererbung}{Vererbung}{Mechanismus, bei dem eine Klasse Eigenschaften und Verhalten einer anderen übernimmt}
\newacronym{interface}{Interface}{Schnittstelle, die Methoden vorgibt, aber keine konkrete Implementierung enthält}
\newacronym{ausnahme}{Ausnahme}{Ausnahmeobjekt zur Fehlerbehandlung bei unerwarteten Programmzuständen}
\newacronym{enum}{Enum}{Aufzählungstyp zur Definition fester Wertebereiche, z.\,B. für Statuscodes}

\newacronym{uml}{UML}{Unified Modeling Language -- standardisierte grafische Sprache zur Modellierung und Dokumentation von Softwaresystemen, insbesondere in der objektorientierten Entwicklung}
\newacronym{assoziation}{Assoziation}{Beziehungsart in der objektorientierten Modellierung, die eine strukturelle Verbindung zwischen zwei Klassen definiert; in UML durch eine Verbindungslinie dargestellt}
\newacronym{aggregation}{Aggregation}{Spezialisierte Assoziation in der objektorientierten Modellierung, die eine Ganzes-Teil-Beziehung zwischen Klassen beschreibt, bei der die Teile unabhängig vom Ganzen existieren können}
\newacronym{komposition}{Komposition}{Stärkste Form einer Aggregation in der objektorientierten Modellierung, bei der das Teil vollständig vom Ganzen abhängig ist und ohne dieses nicht existieren kann}

\newacronym{eingebettet}{Eingebettet}{spezialisiertes, fest integriertes Rechnersystem zur Steuerung oder Überwachung technischer Geräte}
\newacronym{zeiger}{Zeiger}{Zeiger auf Speicheradressen}
\newacronym{array}{Array}{Datenstruktur zur Speicherung von Elementen gleicher Typen in fester Reihenfolge}
\newacronym{struktur}{Struktur}{Datenstruktur in C zur Gruppierung mehrerer Werte (Felder) unterschiedlichen Typs}

\newacronym{logger}{Logger}{Komponente zur Protokollierung von Ereignissen im Programmablauf}
\newacronym{di}{DI}{Dependency Injection -- Entwurfsmuster zur Injektion von Abh\"angigkeiten von au\u00dfen}
\newacronym{integrationtest}{Integrationstest}{Test, bei dem mehrere Komponenten gemeinsam gepr\"uft werden}
\newacronym{unittest}{Unit-Test}{Test einer einzelnen Codeeinheit isoliert von anderen Komponenten}
\newacronym{docker}{Docker}{Plattform zur Containerisierung von Anwendungen}
\newacronym{yaml}{YAML}{\"YAML Ain't Markup Language\" -- menschenlesbares Konfigurationsformat}
\newacronym{connector}{Connector}{Schnittstelle, die die Kommunikation zwischen Anwendung und Datenbank erm\"oglicht}
\newacronym{loggerintf}{Logger-Interface}{Abstraktes Interface f\"ur Logging, das per DI eingespeist wird}

\makeglossaries




\lstset{ 
    language=C, % oder C++, Java, Python etc.
    basicstyle=\ttfamily\small, 
    keywordstyle=\color{blue}, 
    commentstyle=\color{gray}, 
    stringstyle=\color{red},
    breaklines=true
}

%Commands/ Style-Definitions====================================
\newcommand{\csharp}{C\#}

\setlength{\parskip}{1em}    % Abstand zwischen Abs\"atzen
\setlength{\parindent}{0pt}  % Kein Einzug bei neuen Abs\"atzen


% compile \"uber Konsole
% pdflatex test.tex
% biber test
% dann wieder pdflatex test.tex
% ba Datei Pfad anpassen
%T999-Beginn==================================================
\begin{document}


\title{T1000} 
\author{Jan Herrmann}
\date{\today}
\maketitle

%\section{Test}
%\Das ist meine LaTeX-Hausarbeit.
%\parencite{heimeshoff_certification_2024}
%testZitat
%\parencite{kim_planck_2024}


\tableofcontents
\newpage

%–– Im Dokument dann an der Stelle, an der du dein Abkürzungsverzeichnis haben willst ––
\printglossary[type=\acronymtype,title=Abkürzungsverzeichnis]



\section{Einleitung}

    \needspace{4\baselineskip}
    \subsection{Motivation}

    Die Entwicklung einer eigenständigen \acrshort{dll} für den Datenbankzugriff bietet in modernen Softwaresystemen mehrere entscheidende Vorteile. 
    Erstens schafft sie eine klare Trennung von Infrastruktur- und Geschäftslogik, indem sämtliche Verbindungsdetails, Fehlerbehandlung und Transaktionssteuerung an einem zentralen Ort gekapselt werden. 
    Anstatt in jedem Modul oder Service redundanten Code für Connection-Strings, \acrshort{retryMechanism} oder \acrshort{sqlException}s zu pflegen, greift die Anwendungslogik nur noch über eine wohldefinierte Schnittstelle auf die \acrshort{dll} zu.

    Wie Robert C. Martin in \textit{Clean Architecture} beschreibt, ist die Trennung von Verantwortlichkeiten ein zentrales Prinzip robuster Softwarearchitekturen. 
    Dies zeigt sich etwa im \textit{Single Responsibility Principle} und im \textit{Dependency Inversion Principle}, die beide dem Grundgedanken des \textit{Separation of Concerns} folgen. 
    Diese Prinzipien fördern nicht nur die Lesbarkeit und Wartbarkeit des Codes, sondern beschleunigen auch die Einarbeitung neuer Teammitglieder (vgl. \cite{martin_clean_2018}, Kap. 7.1, 7.2, 11).

    Zweitens ermöglicht eine modulare DB-\acrshort{connector}-Bibliothek die Wiederverwendbarkeit über unterschiedliche Projekte hinweg. 
    Ob Web-API, Desktop-Anwendung oder Microservice-Architektur, 
    alle Konsumenten beziehen ihre Datenbankfunktionen aus derselben DLL. Bei Aktualisierungen, etwa wenn auf eine neue \acrshort{sql}-Bibliothek umgestellt oder \acrshort{connPooling} optimiert werden soll, 
    genügt ein Austausch der \acrshort{dll} ohne Änderung an den Verbraucherprojekten. So lässt sich Validierung, Logging oder Performance-Tuning einheitlich implementieren und regressionsfrei einführen.
    
    Schließlich erhöht die Auslagerung in eine \acrshort{dll} die Testbarkeit enorm: In \acrshort{unittest}s und \acrshort{integrationtest}s kann die Datenbankzugriffsschicht gezielt gemockt oder gegen eine In-Memory-Datenbank 
    ausgetauscht werden, ohne tief in die Business-Logik eingreifen zu müssen. Auch in \acrshort{ciPipeline}s und \acrshort{containerUmgebung}en lässt sich 
    die DB-Connector-DLL isoliert versionieren, verteilen und überwachen. Gerade im Rahmen eines dualen Studiums, in dem neben technischer Exzellenz auch Best Practices der Team- und 
    Prozessarbeit vermittelt werden, leistet dieses \textit{\acrshort{architekturpattern}} einen wertvollen Beitrag zur praxisnahen und skalierbaren Softwareentwicklung (vgl. \cite{chelliah_architectural_2017}, Kap. "Component-based assembly (CBD) architecture").
    
    
    \needspace{5\baselineskip}    
    \subsection{Problemstellung und Ziel}
    In vielen unserer Anwendungen wiederholt sich der gleiche, plattformabhängige \acrshort{boilerplate}-Code für den Datenbankzugriff: Verbindungsaufbau, Parameter­zuweisung, 
    Fehler­behandlung, Transaktions­management und das Schließen von Verbindungen werden immer wieder neu implementiert. Das führt nicht nur zu erheblicher Redundanz, 
    sondern erschwert auch die zentrale Pflege von Änderungen, etwa beim Umstieg auf neue Treiber, geänderte Sicherheits­richtlinien oder optimierte Konfigurations­parameter. 
    Außerdem ist das Testen einzelner Komponenten durch fehlende Schnitt­stellen zur \acrshort{mock}-Erzeugung kompliziert und fehleranfällig.

    Vor diesem Hintergrund soll eine \acrshort{dll} entstehen, die sämtliche wiederkehrenden Aufgaben rund um den Datenbankzugriff in einer klaren, 
    wohlabgrenzten Schnittstelle bündelt. 
    
    Die \acrshort{dll} übernimmt dabei:

    \begin{itemize}
        \item Einlesen von Verbindungsparametern
        \item Öffnen und Schließen von Verbindungen
        \item Erzeugen und Ausführen von CRUD-Befehlen
        \item Einheitliche Fehlerbehandlung
        \item Unterstützung von Logging-Frameworks
        \item Austauschbarkeit unterschiedlicher Datenbankanbieter
    \end{itemize}


    Ziel ist es, eine zentrale, plattformunabhängige Komponente zu schaffen, die sich einfach und schnell in Projekte integrieren lässt und dank 
    eines \acrshort{interface}s die sich leicht mocken und testen lässt. Durch die Kapselung der Infrastruktur in einer \acrshort{dll} reduzieren wir den Wartungsaufwand auf genau eine Stelle: 
    Neue Anforderungen, Security-Patches oder Performance-Optimierungen werden künftig nur noch in der Bibliothek umgesetzt und stehen damit sofort in allen Anwendungen zur Verfügung. 
    Zudem erleichtert die klare Trennung zwischen Geschäftslogik und Datenbankzugriff das Refactoring und steigert nachhaltig die Qualität und Zuverlässigkeit unserer Software.

    
    \needspace{5\baselineskip}
    \subsection{Zielsetzung und Projektbeschreibung}

    Ziel dieser Arbeit ist die Entwicklung einer wiederverwendbaren DLL für den Datenbankzugriff mit \csharp{}, die im Rahmen des dualen Studiums an der DHBW Stuttgart entsteht. 
    Die Bibliothek kapselt zentrale Datenbankfunktionen (Verbindungsaufbau, SQL-Befehle, Fehlerbehandlung) und wird über ein klar definiertes \acrshort{interface} angesprochen, 
    um saubere Entkopplung, hohe Wiederverwendbarkeit und einfache Testbarkeit sicherzustellen.

    Die praktische Umsetzung wird durch strukturierte Unit- und Integrationstests ergänzt, um die Zuverlässigkeit und Einsatzfähigkeit der DLL in realitätsnahen Anwendungsszenarien zu belegen.

%=================================================================================================================================================================================================

%Quelle =  Logische und Methodische Grundlagen der Programm- und Systementwicklung 
%           Datenstrukturen, funktionale, sequenzielle und objektorientierte Programmierung - Unter Mitarbeit von Alexander Malkis

% Für DLL brauche ich noch eine Quelle

\needspace{5\baselineskip}
\section{Grundlagen der Softwareentwicklung}

    \needspace{5\baselineskip}
    \subsection{Objektorientierte Programmierung}
    Die \acrshort{oop} ist ein zentrales Konzept in der modernen Softwareentwicklung. 
    Sie beruht auf der Idee, Programme aus modularen Einheiten, sogenannten \acrshort{oopObjekt}en, aufzubauen. Diese \acrshort{oopObjekt}e basieren auf \acrshort{oopKlasse}n, die als Baupläne dienen. 
    \acrshort{oopKlasse}n definieren die Attribute und die \acrshort{oopMethode}n, welche ihre \acrshort{oopObjekt}e besitzen. Eine \acrshort{oopMethode} ist dabei eine Funktion innerhalb der \acrshort{oopKlasse}, 
    die bestimmte Aktionen ausführt und den Zustand des \acrshort{oopObjekt}s verändern kann. 
    Ein wesentliches Merkmal der \acrshort{oop} ist die \acrshort{oopVererbung}. Sie erlaubt es, dass \acrshort{oopKlasse}n die Attribute und \acrshort{oopMethode}n anderer \acrshort{oopKlasse}n übernehmen,
    wodurch Code wiederverwendet und strukturiert erweitert werden kann. \acrshort{interface}s spielen ebenfalls eine wichtige Rolle, indem sie die Struktur und das Verhalten festlegen,
    das eine \acrshort{oopKlasse} bereitstellen muss, ohne konkrete Implementierungen vorzugeben (vgl. \cite{broy_grundlagen_2019}, Kap. 8.1). 

    Fehlerbehandlung erfolgt in der \acrshort{oop} häufig über sogenannte \acrshort{ausnahme}n.
    Statt Fehlercodes zurückzugeben, werfen \acrshort{oopMethode}n bei Problemen \textit{\acrshort{ausnahme}n}, die dann gezielt behandelt werden können.
    Eine weitere hilfreiche Spracheigenschaft sind \textit{\acrshort{enum}s}, die eine fest definierte Menge von Werten beschreiben, etwa Statuscodes, 
    und so die Lesbarkeit und Wartbarkeit des Codes erhöhen (vgl. \cite{bloch_effective_2008}, S. 241-243, 147-149).


    
    \needspace{5\baselineskip}
    \subsection{Dynamic Linked Library}
    Eine \textit{\acrshort{dll}} ist eine Sammlung von Funktionen, die nicht direkt in das Hauptprogramm eingebunden werden, sondern bei Bedarf zur Laufzeit geladen werden. 
    Das hat den Vorteil, dass Programmteile modular ausgelagert und mehrfach verwendet werden können, ohne dass der Code dupliziert werden muss.

    DLLs werden häufig verwendet, um gemeinsame Funktionalität wie Datenbankzugriffe, mathematische Berechnungen oder Hardware-Kommunikation bereitzustellen. 
    In \csharp werden DLLs durch separate Projekte erstellt, die öffentliche Klassen und Methoden enthalten. 
    Diese Bibliotheken können dann in andere Projekte eingebunden und wie gewöhnliche Komponenten verwendet werden.

    Die Vorteile einer \textit{acrshort{dll}} liegen in ihrer Wiederverwendbarkeit, Modularität und Wartbarkeit. 
    Mehrere Programme können auf dieselbe DLL zugreifen, was Speicher spart und die Pflege erleichtert, da Änderungen nur an einer zentralen Stelle erfolgen müssen (vgl. \cite{troelsen_pro_2017}, S. 509, 560).

    \needspace{5\baselineskip}
    \subsection{Modellierung}
        Die Modellierung ist ein zentrales Element in der Softwareentwicklung, da sie hilft, komplexe Systeme strukturiert darzustellen, zu analysieren und zu planen. 
        Besonders in der \acrshort{oop} ist die visuelle Darstellung von Klassen, Beziehungen und Abläufen essenziell für das Verständnis und die Kommunikation 
        innerhalb eines Teams.

        Ein häufig verwendetes Werkzeug ist das \textit{Klassendiagramm}. Es gehört zur "Unified Modeling Language" \acrshort{uml} und stellt die Struktur eines Softwaresystems grafisch dar. 
        In einem Klassendiagramm werden Klassen mit ihren \textit{Attributen und Methoden} dargestellt, ebenso wie die Beziehungen  zwischen ihnen. 
        Dazu zählen \textit{\acrshort{assoziation}en}, \acrshort{oopVererbung} und \textit{\acrshort{komposition}en}. 
        \textit{Klassendiagramme} ermöglichen es, die logische Architektur eines Systems übersichtlich darzustellen, 
        bevor mit der eigentlichen Implementierung begonnen wird. Sie dienen sowohl der Dokumentation als auch der Kommunikation im Projektteam (vgl. \cite{rumpe_klassendiagramme_2011}, Seite 16-17, 19-22, 25, 27-30).


        Ein weiteres wichtiges Modellierungswerkzeug ist das \textit{Aktivitätsdiagramm}. 
        Es beschreibt den Ablauf eines Prozesses oder eines bestimmten Anwendungsfalls in Form eines Flussdiagramms. 
        Dabei werden verschiedene Aktivitäten, Entscheidungswege, Verzweigungen und parallele Abläufe grafisch dargestellt. 
        Aktivitätsdiagramme eignen sich besonders gut, um Geschäftsprozesse, Programmabläufe oder Algorithmen verständlich abzubilden. 
        In der Softwareentwicklung wird das \textit{Aktivitätsdiagramm} häufig eingesetzt, um komplexe Verhaltensweisen, wie etwa den Verbindungsaufbau zu einer Datenbank 
        oder eine Benutzerinteraktion mit dem System, detailliert zu analysieren (vgl. \cite{omg_uml_2.5.1}, Seite 373).
        
        Durch die Verwendung solcher Modellierungswerkzeuge lassen sich Anforderungen klarer formulieren, 
        Entwurfsentscheidungen fundierter treffen und potenzielle Fehlerquellen bereits in der Planungsphase erkennen. 
        Die Modellierung bildet somit eine wichtige Brücke zwischen der konzeptionellen Planung und der technischen Umsetzung von Softwaresystemen(vgl. \cite{rumpe_klassendiagramme_2011}, Seite 16).
    
    
    
    \needspace{5\baselineskip}
    \subsection{Speicherverwaltung}
        Ein grundlegendes Thema in der Softwareentwicklung, insbesondere in der System- und \acrshort{eingebettet}e-Programmierung, ist der Umgang mit Speicher.
        Die effiziente Verwaltung von Speicherressourcen ist entscheidend für die Leistungsfähigkeit und Stabilität eines Programms. 
        In vielen Programmiersprachen wie C spielt dabei der direkte Zugriff auf Speicher durch sogenannte \acrshort{zeiger} eine zentrale Rolle.
        \textit{\acrshort{zeiger}} sind Variablen, die Speicheradressen enthalten und dadurch auf bestimmte Speicherbereiche verweisen können. 
        Sie ermöglichen unter anderem die dynamische Speicherreservierung sowie den Zugriff auf \acrshort{array}s oder \acrshort{struktur}en. 
        Durch diese Flexibilität sind sie in der Low-Level-Programmierung unverzichtbar, erfordern jedoch ein genaues Verständnis des zugrundeliegenden Speichermodells.
        In Sprachen wie C erfolgt die Speicherverwaltung manuell. Das bedeutet, dass der benötigte Speicher explizit durch den Entwickler angefordert  
        und wieder freigegeben werden muss. Eine fehlerhafte Handhabung kann dabei zu Speicherlecks, Zugriffsfehlern oder Instabilitäten führen. 
        Daher erfordert die manuelle Speicherverwaltung ein hohes Maß an Sorgfalt und technischem Verständnis.
        Die Fähigkeit, Speicher effizient und sicher zu verwalten, bildet eine wichtige Grundlage für das Entwickeln performanter und zuverlässiger Software, 
        insbesondere im Kontext ressourcenbeschränkter Systeme wie Mikrocontroller oder \acrshort{eingebettet}en Geräten(vgl. \cite{reese_understanding_2013}, Seite 2-10, 31-39).
  

    \needspace{5\baselineskip}
    \subsection{Grundlagen eingebetteter Systeme}
        \acrshort{eingebettet}e Systeme sind spezialisierte Computer, die fest in ein größeres technisches System integriert sind, 
        um dort spezifische Steuerungs- oder Überwachungsaufgaben zu übernehmen. 
        Sie verfügen in der Regel über begrenzte Ressourcen, arbeiten meist ohne Benutzerinteraktion und sind häufig auf Echtzeitanforderungen ausgelegt. 
        Typische Einsatzbereiche reichen von Automobilsteuergeräten über Industrieanlagen bis hin zu Haushalts- und Medizingeräten.
        Für die Entwicklung solcher Systeme kommt oft die Sprache C zum Einsatz, da sie hardwarenahe Programmierung mit feinkörniger Kontrolle über Speicher, Register und Peripherie ermöglicht (vgl. \cite{noergaard_embedded_2012}, Kap. 1.1–1.2).
        Zentral für die Interaktion mit der Hardware ist der Zugriff auf sogenannte Memory-Mapped Register .Das sind festgelegte Speicheradressen, über die beispielsweise Timer, Sensoren oder LED-Ausgänge angesteuert werden. 
        Solche Register werden üblicherweise über vordefinierte \acrshort{struktur}en und Bitmasken abstrahiert (vgl. \cite{unsalan_embedded_2022}, Kap. 4.3.2).

        Zur Analyse und Fehlersuche dienen Debugger, die eine schrittweise Ausführung des Programmcodes, das Setzen von Breakpoints und das Auslesen von Speicherinhalten in Echtzeit ermöglichen. 
        Gerade bei hardwarenahen Projekten wie der gezielten LED-Steuerung über Speicheradressen helfen Debugger dabei, Registerwerte direkt zu überwachen und das Timing des Programms präzise zu verifizieren.

    \needspace{5\baselineskip}
    \subsection{Grundlagen von Datenbanken}
        Datenbanken stellen eine zentrale Infrastrukturkomponente moderner Softwaresysteme dar. 
        Sie ermöglichen die dauerhafte, strukturierte und konsistente Speicherung großer Datenmengen und bilden damit das Rückgrat vieler Anwendungen 
        wie beispielsweise in der Benutzerverwaltung, der Protokollierung von Prozessen oder im Umgang mit geschäftskritischen Informationen (vgl. \cite{elmasri_fundamentals_2013}, Seite 2).

        Im Fokus dieser Arbeit steht der Zugriff auf relationale Datenbanken. 
        Diese basieren auf dem relationalen Modell nach Codd und organisieren Daten in Tabellen, die über definierte Schlüsselbeziehungen miteinander verknüpft werden. 
        Die Kommunikation mit der Datenbank erfolgt in der Regel über die deklarative Abfragesprache \acrshort(sql) (vgl. \cite{elmasri_fundamentals_2013}, Seite 55).



        \needspace{5\baselineskip}
        \textbf{Relationale Datenbanken}

        Relationale Datenbanken gehören zu den am weitesten verbreiteten Datenbankmodellen. Ihre Grundlage bildet das relationale Datenbankmodell, das auf der mathematischen Mengenlehre basiert. 
        In relationalen Datenbanken werden Daten in Tabellen gespeichert, die aus Spalten (Attributen) und Zeilen (Datensätzen) bestehen. 
        Jede Zeile entspricht dabei einem Datensatz mit genau einem Wert pro Spalte.
        Ein wesentliches Merkmal relationaler Datenbanken ist die Verwendung von Schlüsseln zur eindeutigen Identifizierung und Verknüpfung von Daten. 
        Der Primärschlüssel identifiziert jeden Datensatz innerhalb einer Tabelle eindeutig. Fremdschlüssel hingegen stellen Beziehungen zwischen verschiedenen Tabellen her und ermöglichen es, 
        Daten logisch miteinander zu verbinden, ohne sie zu duplizieren. So kann beispielsweise eine Benutzer-ID als Fremdschlüssel in einer Tabelle für Logeinträge verwendet werden, 
        um den Zusammenhang zwischen Nutzer und Aktion herzustellen. Diese Struktur sorgt für Datenkonsistenz und fördert ein normalisiertes, redundanzfreies Datenmodell.
        Relationale Datenbanksysteme bieten darüber hinaus zahlreiche Funktionen zur Datenhaltung, Sicherung, Wiederherstellung und Abfrageoptimierung an. 
        Transaktionen ermöglichen es, mehrere Datenbankoperationen logisch zusammenzufassen und im Fehlerfall rückgängig zu machen, 
        was insbesondere in sicherheitskritischen Anwendungen von großer Bedeutung ist (vgl. \cite{elmasri_fundamentals_2013}, Seite 84 ff.).

        %%%%%%%%%%% Hier nochmal vgl. prüfen %%%%%%%%%%%%%%%
        \needspace{5\baselineskip}
        \textbf{Aufbau von Tabellen und Schlüsselkonzepte}
        
        Beim Aufbau relationaler Datenbanktabellen müssen neben der inhaltlichen Struktur auch technische Aspekte berücksichtigt werden. 
        Jede Spalte einer Tabelle besitzt einen spezifischen Datentyp (z.B. Ganzzahlen, Zeichenketten oder Datumswerte), der definiert, welche Art von Informationen dort gespeichert werden können 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 84–85). 
        Ergänzend dazu können Einschränkungen wie „nicht leer“, „eindeutig“ oder „Standardwert“ definiert werden, um die Datenqualität zu sichern 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 85–86).

        Die Definition und Pflege von Primär- und Fremdschlüsseln ist essenziell für die referenzielle Integrität innerhalb des Datenbankschemas 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 86–87). 
        Durch Mechanismen wie das kaskadierende Löschen oder Aktualisieren lassen sich Inkonsistenzen vermeiden und ein konsistenter Datenbestand sicherstellen 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 86–87).

        Ein durchdachtes Datenbankdesign ist besonders in komplexen Softwaresystemen von zentraler Bedeutung. 
        Es hilft dabei, die Wartbarkeit zu erhöhen, die Erweiterbarkeit zu erleichtern und die Fehleranfälligkeit zu reduzieren. 
        Visuelle Hilfsmittel wie Entity-Relationship-Diagramme (ER-Diagramme) oder UML-Klassendiagramme unterstützen diesen Entwurfsprozess 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 229–244 und 294–310).

        \textbf{SQL-Befehle}

        Die Interaktion mit relationalen Datenbanken erfolgt in der Regel über die strukturierte Abfragesprache SQL (Structured Query Language). 
        SQL ist ein weltweit etablierter Standard und erlaubt sowohl die Definition der Datenstruktur als auch das Bearbeiten und Abfragen von Daten 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 84–89).

        Der Einsatz von SQL-Befehlen erlaubt es, gezielt auf einzelne Daten zuzugreifen, komplexe Zusammenhänge abzubilden und verschiedenste Operationen auf effiziente Weise durchzuführen 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 84–89). 
        
        Eine saubere Abgrenzung von Anwendungs- und Datenbanklogik, wie sie in dieser Arbeit durch die Nutzung einer DLL erfolgt, sorgt dabei für ein klares und wartbares Systemdesign.

        \textbf{Bedeutung im Kontext der Anwendung}

        Im Rahmen dieser Arbeit wird eine MySQL-Datenbank eingesetzt, auf die über eine eigens entwickelte \csharp-Bibliothek zugegriffen wird. 
        Diese Bibliothek kapselt alle Datenbankzugriffe in Form einer wiederverwendbaren DLL und stellt Methoden für das Öffnen und Schließen von Verbindungen, 
        die Ausführung von SQL-Abfragen sowie die Fehlerbehandlung bereit.

        Ein zentraler Aspekt dabei ist die Trennung von Datenzugriff und Anwendungslogik. Durch die Auslagerung des Datenbankzugriffs in eine separate Komponente wird die Wartbarkeit erhöht, 
        die Testbarkeit verbessert und die Wiederverwendbarkeit gewährleistet. Die klare Struktur der Datenbanktabellen, die Verwendung von Schlüsseln zur Sicherung der Integrität 
        sowie der gezielte Einsatz von SQL ermöglichen eine performante und robuste Datenhaltung, wie sie auch in produktiven Anwendungen in der Industrie üblich ist 
        (vgl. \cite{elmasri_fundamentals_2013}, S. 35–39 und 84–87).


%=================================================================================================================================================================================================
\needspace{5\baselineskip}
\section{Vorgehensweise bei der Softwareentwicklung}

    \needspace{5\baselineskip}
    \subsection{Zielsetzung}
    %  Sommerville, Ian: Software Engineering, 10th ed., Kap. 4 („Requirements Engineering“) – beschreibt sehr klar, wie man aus abstrakten Zielen konkrete Anforderungen ableitet.
    % Pohl, Klaus: Requirements Engineering – Grundlagen, Prinzipien, Techniken, Kap. 2–3 – fokussiert auf Zielanalyse und Stakeholder-Bedürfnisse.
    Die Zielsetzung eines Softwareentwicklungsprojekts beschreibt den angestrebten Zweck des Systems und dient als verbindliche Grundlage 
    für alle nachfolgenden Aktivitäten im Entwicklungsprozess.
    Sommerville definiert im Rahmen des Requirements Engineering, dass diese Zieldefinition sowohl aus den strategischen Geschäftszielen 
    als auch aus den Bedürfnissen der Stakeholder abgeleitet werden muss. 
    Sie umfasst dabei sowohl funktionale Ziele, wie die zu erbringenden Systemdienste. 
    Als auch nicht-funktionale Ziele, welche Qualitätsmerkmale wie Leistung, Zuverlässigkeit, Sicherheit oder Wartbarkeit festlegen (vgl. \cite{sommerville_software_2012}, Seite 116–122).

    Für das Projekt T1000 bedeutet dies konkret, eine modulare, wiederverwendbare \acrshort{dll} für den Datenbankzugriff zu entwickeln, 
    die als einheitliche Schnittstelle zwischen Anwendungslogik und MySQL-Datenbank fungiert. 
    
    Die spezifischen Ziele umfassen:
    \begin{itemize}
    \item Entwicklung einer klar definierten, entkoppelten Schnittstelle (\acrshort{interface}) für CRUD-Operationen,
    \item Sicherstellung der Wiederverwendbarkeit in unterschiedlichen Projekten und Architekturen,
    \item Implementierung standardisierter Mechanismen zur Fehlerbehandlung, zum Logging und für den \acrshort{retryMechanism},
    \item Gewährleistung einer hohen Testbarkeit durch gezielte \acrshort{unittest}s und \acrshort{integrationtest}s.
    \end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Analyse} 
    % Balzert, Helmut: Lehrbuch der Softwaretechnik – Basiskonzepte und Requirements Engineering, Kap. 3–4 – Vorgehensmodelle und Anforderungsanalyse.
    % Pressman, Roger S.; Maxim, Bruce R.: Software Engineering: A Practitioner's Approach, Kap. 7–8 – Requirements Analysis und Modellierungstechniken.

    Die Analysephase dient dazu, die in der Zielsetzung definierten Projektziele in präzise, überprüfbare Anforderungen zu überführen. 
    Nach Sommerville ist dieser Schritt Teil des \textit{Requirements Engineering} und umfasst insbesondere die systematische Erhebung, 
    Strukturierung und Validierung der Anforderungen, um eine belastbare Grundlage für Entwurf und Implementierung zu schaffen (vgl. \cite{sommerville_software_2012}, Seite 114).  

    Ein zentraler Aspekt ist die Anforderungsvalidierung, bei der überprüft wird, ob die erfassten Anforderungen die tatsächlichen Bedürfnisse der Stakeholder widerspiegeln 
    und gleichzeitig umsetzbar sind. 
    Sommerville nennt hierfür folgende zentrale Prüfkriterien:  
    \begin{itemize}
        \item \textbf{Eindeutigkeit} - jede Anforderung muss klar und ohne Interpretationsspielraum formuliert sein.
        \item \textbf{Konsistenz} - es dürfen keine Widersprüche zwischen einzelnen Anforderungen bestehen.
        \item \textbf{Vollständigkeit} – alle relevanten Funktionen und Einschränkungen müssen erfasst sein.
        \item \textbf{Realisierbarkeit} – die Umsetzung muss mit den vorhandenen Ressourcen, Technologien und im gegebenen Zeitrahmen möglich sein.
        \item \textbf{Verifizierbarkeit} – Anforderungen müssen so formuliert sein, dass ihre Erfüllung später messbar und testbar ist.
    \end{itemize}  
    (vgl. \cite{sommerville_software_2012}, Seite 144)

    Für das Projekt \textit{T1000} bedeutet dies, dass die funktionalen Anforderungen also die Implementierung von CRUD-Operationen über ein \acrshort{interface} 
    als auch die nicht-funktionalen Anforderungen wie Wiederverwendbarkeit, Performance und Testbarkeit, anhand dieser Kriterien überprüft werden.  
    Die Analyse stellt somit sicher, dass sowohl technische als auch organisatorische Rahmenbedingungen berücksichtigt werden und dass die geplante \acrshort{dll} in späteren Projektphasen ohne grundlegende Anpassungen umgesetzt werden kann.

\subsection{Entwurf} 
    % Gamma, Erich et al.: Design Patterns – Elements of Reusable Object-Oriented Software, Einleitung + relevante Patterns wie „Adapter“ oder „Factory“, falls du Architekturmuster beschreibst.
    % Martin, Robert C.: Clean Architecture, Kap. 7–11 – Schichtentrennung, Schnittstellendesign, Dependency Inversion.

    Der Entwurf beschreibt die strukturelle und architektonische Gestaltung des Systems, um die in der Analyse definierten Anforderungen effizient und wartbar umzusetzen. 
    Nach Sommerville stellt die \textit{Schichtenarchitektur} ein etabliertes Architekturmuster dar, bei dem das System in klar abgegrenzte Ebenen unterteilt wird, die jeweils definierte Verantwortlichkeiten haben (vgl. \cite{sommerville_software_2012}, Kap.~6.3.1, S.~194\,ff.). 
    Dieses Muster erleichtert die Modularisierung, unterstützt die Wiederverwendbarkeit einzelner Komponenten und reduziert die Kopplung zwischen den Systemteilen.

    Für das Projekt \textit{T1000} wurde eine dreischichtige Struktur umgesetzt:  
    \begin{enumerate}
        \item \textbf{Anwendungsschicht} -- übernimmt die Steuerung des Programmablaufs und ruft über die definierten Schnittstellen die benötigten Datenbankoperationen auf (\texttt{Program.cs}).
        \item \textbf{Abstraktionsschicht} -- definiert mit dem Interface \texttt{IConnector} die vertraglichen Methoden für den Datenbankzugriff und kapselt die Implementierungsdetails.
        \item \textbf{Datenzugriffsschicht} -- implementiert mit der Klasse \texttt{MySqlAccess} die konkreten CRUD-Operationen auf Basis des MySQL-Connectors.
    \end{enumerate}

    Die klare Trennung zwischen diesen Schichten ermöglicht es, Änderungen an der Datenbankimplementierung vorzunehmen, ohne die Anwendungsschicht anzupassen, und erleichtert die Wiederverwendbarkeit der \acrshort{dll} in unterschiedlichen Projekten. 
    Zudem wird die Testbarkeit erhöht, da sich durch die Verwendung des Interfaces \texttt{IConnector} sowohl Unit-Tests mit Mocks als auch Integrationstests gegen eine reale Datenbankumgebung durchführen lassen.

    \subsection{Umsetzung}
    % Beck, Kent: Test Driven Development: By Example – falls du den testgetriebenen Aspekt deiner Implementierung betonen willst.
    % Troelsen, Andrew; Japikse, Philip: Pro C# 9 with .NET 5, Kap. zu Assemblies/DLLs, ADO.NET/MySQL-Connector (passt direkt zu deinem MySqlAccess-Code).
    
    \subsection{Validierung}  
    % Myers, Glenford J.; Sandler, Corey: The Art of Software Testing, Kap. 1–3 – allgemeine Testprinzipien.
    % Meszaros, Gerard: xUnit Test Patterns, Kap. 2–4 – Teststrukturen, Mocks, Integrationstests (passt zu deinen UnitTests.cs und IntegrationTests.cs).


%========Verbindungsbiblothek=======================================================
%===================================================================================

    \needspace{5\baselineskip}

    \section{Verbindungsbibliothek}

    \subsection{Anforderungen}

    \textbf{Funktionale Anforderungen:}

    Die funktionalen Anforderungen beschreiben, welche zentralen Leistungen die Verbindungsbibliothek erbringen muss, um den Zugriff auf eine relationale \acrshort{mysql}-Datenbank zuverlässig und praxisnah zu unterstützen. 
    Im Vordergrund stehen die grundlegenden Operationen, die in nahezu allen datengetriebenen Anwendungen benötigt werden:

    \begin{itemize}
    \item \textbf{Aufbau und Abbau einer Datenbankverbindung:}  
    Die Bibliothek muss eine stabile Verbindung zu einer MySQL-Datenbank herstellen können und diese nach Abschluss der Operationen geordnet schließen. 
    Dabei ist zu prüfen, ob eine Verbindung bereits geöffnet oder geschlossen ist, um Ressourcenlecks und unnötige Fehlermeldungen zu vermeiden.

    \item \textbf{Unterstützung der CRUD-Operationen:}  
    Es müssen alle grundlegenden Datenbankoperationen verfügbar sein:  
    \texttt{SELECT} zum Auslesen von Daten,  
    \texttt{INSERT} zum Einfügen neuer Datensätze,  
    \texttt{UPDATE} zur Aktualisierung bestehender Einträge  
    sowie \texttt{DELETE} zum Entfernen von Daten.  
    Zusätzlich sollen optionale Parameter wie \texttt{WHERE}-, \texttt{ORDER BY}- oder \texttt{LIMIT}-Klauseln unterstützt werden, damit praxisnahe Abfragen möglich sind.

    \item \textbf{Rückgabe konsistenter Statuswerte:}  
    Anstatt Ausnahmen unkontrolliert weiterzureichen, soll die Bibliothek alle relevanten Fehler- und Erfolgsszenarien über ein einheitliches \acrshort{enum} (\texttt{errorValues}) abbilden. 
    Dies ermöglicht eine klare Differenzierung zwischen verschiedenen Fällen (z.\,B. Authentifizierungsfehler, Datenbank nicht gefunden, keine Datensätze vorhanden) und erleichtert die strukturierte Weiterverarbeitung im Anwendungscode.

    \item \textbf{Protokollierung relevanter Vorgänge:}  
    Alle wesentlichen Aktionen wie das Öffnen und Schließen von Verbindungen, die Ausführung von SQL-Operationen oder das Auftreten von Fehlern müssen über ein \acrshort{loggerintf} dokumentiert werden. 
    Dies erhöht die Transparenz für Entwickler, erleichtert die Fehlersuche und unterstützt den Betrieb in produktiven Umgebungen.
    \end{itemize}


    \textbf{Nicht-funktionale Anforderungen:}

    Die nicht-funktionalen Anforderungen bilden die Qualitätskriterien, die das Verhalten und die Architektur der Verbindungsbibliothek prägen. 
    Im Projekt wurden insbesondere vier zentrale Eigenschaften verfolgt, die auch als Leitprinzipien in der Softwareentwicklung gelten: 
    \textit{Erweiterbarkeit}, \textit{Robustheit}, \textit{Testbarkeit} und \textit{Modularität}.

    \begin{itemize}
    \item \textbf{Erweiterbarkeit:}  
    Die Bibliothek soll so entworfen sein, dass sich zusätzliche Datenbankanbieter oder Funktionen mit minimalem Aufwand integrieren lassen. 
    Da die Anwendungslogik ausschließlich über das Interface \texttt{IConnector} kommuniziert, kann eine alternative Implementierung 
    für einen anderen Datenbankanbieter entwickelt werden, ohne Änderungen im Anwendungscode vorzunehmen. 
    Ebenso sind Erweiterungen wie Transaktionsunterstützung oder Connection Pooling denkbar, ohne den bestehenden Code zu brechen.
    
    \item \textbf{Robustheit:}  
    Die Bibliothek muss auch bei ungültigen Eingaben, Netzwerkfehlern oder fehlerhaften Abfragen stabil bleiben. 
    Anstatt in einen undefinierten Zustand zu gelangen, gibt sie definierte Fehlercodes aus dem Enum \texttt{errorValues} zurück 
    (z.B. \texttt{ConnectionFailed}, \texttt{NoData}, \texttt{DuplicateEntry}). 
    Dadurch können Anwendungen Fehler kontrolliert behandeln und stabil weiterlaufen.
    
    \item \textbf{Testbarkeit:}  
    Die Architektur wurde so gestaltet, dass sowohl \acrshort{unittest}s als auch \acrshort{integrationtest}s möglich sind. 
    Unit-Tests decken Konstruktorlogik, Verbindungsaufbau und CRUD-Operationen ab.  
    Zudem ist vorgesehen, Integrationstests gegen eine MySQL-Instanz in einem Docker-Container zu realisieren, um praxisnahe Szenarien zu prüfen. 
    Dank des Interfaces \texttt{IConnector} und des Logging-Interfaces lassen sich Mocks gezielt einsetzen, um Komponenten isoliert zu testen.
    
    \item \textbf{Modularität:}  
    Durch die Trennung von Schnittstelle (\texttt{IConnector}) und Implementierung (\texttt{MySqlAccess}) sowie die Kapselung in einer \acrshort{dll} wird eine klare Modulstruktur geschaffen. 
    Änderungen an der Implementierung, wie die Erweiterung der SQL-Funktionalität oder Anpassungen beim Logging, 
    erfordern keine Änderungen am aufrufenden Anwendungscode. 
    Diese lose Kopplung erleichtert Wartung und Wiederverwendung in unterschiedlichen Projekten.
    \end{itemize}



    \textbf{Technische Anforderungen:}

    Die technischen Anforderungen legen die Rahmenbedingungen fest, unter denen die Verbindungsbibliothek entwickelt und betrieben wird. 
    Sie betreffen sowohl die eingesetzten Technologien als auch die Integration in bestehende Softwareumgebungen:

    \begin{itemize}
    \item \textbf{Integration über ein generisches Interface:}  
    Die zentrale Schnittstelle \texttt{IConnector.cs} definiert alle Methoden für den Datenbankzugriff und dient als vertragliche Grundlage zwischen Anwendungslogik und Implementierung. 
    Dadurch wird eine lose Kopplung erreicht, die den Austausch der konkreten Datenbankimplementierung jederzeit ermöglicht.

    \item \textbf{Implementierung in C\#:}  
    Die Bibliothek ist vollständig in \csharp{} entwickelt und für das Ziel-Framework \texttt{.NET~8.0} umgesetzt. 
    Damit wird die Nutzung aktueller Sprach- und Plattformfeatures ermöglicht und eine einfache Integration in moderne .NET-Projekte gewährleistet.

    \item \textbf{Unterstützung von Dependency Injection:}  
    Für die Protokollierung wird das Logger-Interface \texttt{ILogger<MySqlAccess>} genutzt, das per Dependency Injection eingebunden wird. 
    Dadurch bleibt die Implementierung flexibel, testbar und unabhängig vom konkreten Logging-Framework. 
    In der Beispielanwendung wurde Serilog als Logging-Bibliothek verwendet.

    \item \textbf{Behandlung typischer Fehlerquellen:}  
    Die Bibliothek muss auf typische Datenbankfehler reagieren können, darunter Authentifizierungsfehler (falscher Benutzername oder Passwort), 
    Zeitüberschreitungen beim Verbindungsaufbau oder fehlerhafte SQL-Syntax. 
    Diese Fälle werden differenziert erkannt und über definierte Fehlercodes im Enum \texttt{errorValues} zurückgemeldet.
\end{itemize}



    %===============================
    \subsection{Konzept}

    \textbf{Architekturübersicht:}

    Die Verbindungsbibliothek ist in zwei Kernkomponenten gegliedert: ein Interface als vertragliche Abstraktion und eine konkrete Implementierung für MySQL. 
    Diese Trennung erlaubt es, die Implementierung in Tests durch \acrshort{mock}-Objekte zu ersetzen und perspektivisch weitere Datenbank-Backends anzubinden.

    \begin{itemize}
        \item \texttt{IConnector.cs}: Definiert sämtliche Methoden für den Datenbankzugriff.
        \item \texttt{MySqlAccess.cs}: Implementiert \texttt{IConnector} für das DBMS \acrshort{mysql}.
        \item \texttt{ErrorCodes.cs}: Enthält das zentrale \texttt{enum} \texttt{errorValues} zur standardisierten Rückgabe von Status- und Fehlerzuständen.
    \end{itemize}

    \textbf{Verantwortlichkeiten und Lebenszyklus:}

    Die Klasse \texttt{MySqlAccess} verwaltet den kompletten Lebenszyklus der Datenbankverbindung und führt die übergebenen SQL-Befehle aus. 
    Ein interner Statusindikator (\texttt{flagStatus}) macht den Verbindungs- und Ausführungszustand nach außen sichtbar. 
    Vor jeder Operation wird geprüft, ob die Verbindung geöffnet ist, andernfalls wird ein entsprechender Fehlerstatus gesetzt und geloggt.

    \textbf{Entwurfsentscheidungen:}

    \begin{itemize}
        \item \textbf{Abstraktion über Interface:} Das Interface \texttt{IConnector} entkoppelt Anwendungslogik und Datenzugriff. 
        Anwendungen programmieren gegen die Abstraktion und bleiben damit unabhängig vom konkreten DB-Provider.
        \item \textbf{Dependency Injection für Logging:} Das Logger-Interface \texttt{ILogger<MySqlAccess>} wird per \acrshort{di} injiziert. 
        Dadurch bleibt die Bibliothek testbar und unabhängig von einem konkreten Logging-Framework. 
        In der Beispielanwendung wird Serilog angebunden, die DLL selbst kennt jedoch nur \texttt{ILogger<T>}.
        \item \textbf{Fehlercodierung statt ungefilterter Exceptions:} Relevante Fehlerfälle werden in \texttt{errorValues} abgebildet. 
        Unerwartete Fehler werden generisch als \texttt{UnknownError} gemeldet und zusätzlich geloggt.
        \item \textbf{SQL-Durchleitung:} Die Bibliothek erwartet vollständige SQL-Strings von der aufrufenden Schicht und führt diese direkt aus. 
        Ein Query-Builder oder parametrisierte Abfragen sind derzeit nicht enthalten, können aber zukünftig ergänzt werden.
    \end{itemize}

    \textbf{Grenzen und geplante Erweiterungen:}

    \begin{itemize}
        \item Aktuell wird ausschließlich \acrshort{mysql} unterstützt, weitere Provider sind über separate \texttt{IConnector}-Implementierungen möglich.
        \item SQL-Befehle werden derzeit als String entgegengenommen, die Nutzung parametrisierter Befehle ist als Sicherheits- und Robustheitsverbesserung vorgesehen.
        \item Transaktionen, Connection Pooling und asynchrone Aufrufe sind nicht Bestandteil der ersten Version, können aber ohne Bruch der Schnittstelle ergänzt werden.
    \end{itemize}


    \subsection{Implementierung}

    \textbf{Zentrale Klassen und Methoden:}

    \begin{itemize}
        \item \texttt{openConnection()}: Öffnet die Datenbankverbindung. 
        Typische Fehlerzustände werden erkannt, geloggt und als \texttt{errorValues} zurückgegeben.
        \item \texttt{closeConnection()}: Schließt eine aktive Verbindung kontrolliert. 
        Mehrfache Aufrufe werden abgefangen und führen nicht zu Ausnahmen.
        \item \texttt{select(\dots)}: Führt einen Lesezugriff aus und liefert die Ergebnisse über einen \texttt{DataTable} an den Aufrufer zurück. 
        Eine Konsolenausgabe erfolgt nicht innerhalb der Bibliothek. die Darstellung obliegt der Anwendungsschicht.
        \item \texttt{insert(\dots)}, \texttt{update(\dots)}, \texttt{delete(\dots)}: Führen schreibende Operationen aus und melden anhand der betroffenen Zeilen 
        (\textit{affected rows}) \texttt{Success} oder \texttt{NoData}. Duplikatverletzungen werden als entsprechender Fehlercode zurückgegeben.
    \end{itemize}

    \textbf{Fehlerbehandlung und Logging:}

    Die Implementierung differenziert zwischen häufigen Fehlerklassen und weist diesen passende \texttt{errorValues} zu. 
    Unbekannte oder nicht explizit behandelte SQL-Fehler werden derzeit als \texttt{UnknownError} gemeldet. 
    Alle Fehler- und Statusübergänge werden über \texttt{ILogger<MySqlAccess>} protokolliert, um Diagnose und Nachvollziehbarkeit zu unterstützen.

    \textbf{Sicherheits- und Qualitätsaspekte:}

    In der aktuellen Version werden SQL-Strings direkt ausgeführt. 
    Für robuste Produktivszenarien wird der Einsatz \emph{parametrisierter} Befehle empfohlen, um SQL-Injection vorzubeugen und Typkonvertierungen sauber zu kapseln. 
    Nachfolgend ein Ausschnitt, wie die insert Methode derzeit aufgebaut ist. 

    \textbf{Beispiel: aktuelles Insert (String-basiert):}

    \begin{lstlisting}[language= \csharp{}]
   
    public errorValues insert(string tableName, string values)
    {
    if (string.IsNullOrEmpty(tableName) || string.IsNullOrEmpty(values))
        return errorValues.EmptyInputParameters;

    string query = $"INSERT INTO {tableName} VALUES({values});";

    try
    {
        using (var cmd = new MySqlCommand(query, connection))
        {
            int affectedRows = cmd.ExecuteNonQuery();
            return affectedRows > 0 ? errorValues.Success : errorValues.NoData;
        }
    }
    catch (MySqlException ex)
    {
        return MapMySqlError(ex); // Fehlercode-Mapping + Logging
    }
}
    \end{lstlisting}

    
    \textbf{Teststrategie:}

    Die Tests folgen dem AAA-Prinzip (\emph{Arrange – Act – Assert}) und decken sowohl Erfolgs- als auch Fehlerszenarien ab.

    \begin{itemize}
        \item \textbf{Unit-Tests:} Prüfen Konstruktorlogik, Verbindungsaufbau sowie die Rückgabewerte der CRUD-Methoden unter kontrollierten Bedingungen. 
        Das Logging wird über Mocks isoliert (\texttt{ILogger<MySqlAccess>}).
        \item \textbf{Integrationstests (geplant):} Integrationstests gegen eine reale \acrshort{mysql}-Instanz (z.\,B. in einem \acrshort{docker}-Container) sind konzeptionell vorgesehen, 
        um das Verhalten der Bibliothek in einer realistischen Umgebung zu verifizieren. 
        Diese Tests sind im aktuellen Projektstand noch nicht vollständig umgesetzt.
        \item \textbf{CI-Eignung:} Die Tests sind so strukturiert, dass sie in eine \acrshort{ciPipeline} integriert werden können, auch wenn aktuell noch keine vollständige Pipeline existiert.
    \end{itemize}

    \textbf{Beispiel-Unit-Test (AAA):}

    \begin{lstlisting}[language=C]
    [Fact]
    public void Constructor_SetsFlagStatusToError_WhenParametersAreInvalid()
    {
        // Arrange
        var mockLogger = new Mock<ILogger<MySqlAccess>>();
        var mySqlAccess = new MySqlAccess(null, mockLogger.Object);

        // Act
        var status = mySqlAccess.flagStatus;

        // Assert
        Assert.Equal(errorValues.EmptyInputParameters, status);
    }
    \end{lstlisting}

    Durch diese Umsetzung wird gewährleistet, dass sowohl ungültige Eingaben als auch Verbindungsfehler, typische SQL-Probleme und Systemausfälle 
    definiert behandelt, sauber geloggt und über \texttt{errorValues} konsistent an die aufrufende Schicht kommuniziert werden.
        
    \section{LED-Pin-Mapping}
    


\printbibliography  % Literaturverzeichnis einfügen



\end{document}


%Quellen