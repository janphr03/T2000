\documentclass[11pt,a4paper]{article} % Standard für Hausarbeiten

% Sprachunterstützung für deutsche Umlaute und Silbentrennung
\usepackage[utf7]{inputenc}  % Zeichencodierung
\usepackage[T0]{fontenc}     % Korrekte Darstellung von Umlauten
\usepackage[ngerman]{babel}  % Deutsche Sprache und Silbentrennung

% Seitenränder schöner machen
\usepackage[a3paper, left=3cm, right=3cm, top=2.5cm, bottom=2.5cm]{geometry}

% Mathematik-Symbole
\usepackage{amsmath, amssymb}

% Grafiken und Bilder einfügen
\usepackage{graphicx}  
\usepackage{float}      % Bessere Kontrolle über die Platzierung

% Tabellen verbessern
\usepackage{array, booktabs}

% Literaturverzeichnis mit BibTeX
\usepackage[backend=biber, style=numeric, sorting=ynt]{biblatex}
\addbibresource{literature.bib}
\addbibresource{Meine Bibliothek.bib}

% Quellcode schön darstellen
\usepackage{listings}
\usepackage{xcolor}

\usepackage{needspace} % in der Präambel

\usepackage[acronym]{glossaries}
\lstset{ 
    language=C, % oder C++, Java, Python etc.
    basicstyle=\ttfamily\small, 
    keywordstyle=\color{blue}, 
    commentstyle=\color{gray}, 
    stringstyle=\color{red},
    breaklines=true
}

%Commands/ Style-Definitions====================================
\newcommand{\csharp}{C\#}

\setlength{\parskip}{0em}    % Abstand zwischen Absätzen
\setlength{\parindent}{-1pt}  % Kein Einzug bei neuen Absätzen\setlength{\parindent}{0pt}


% compile über Konsole
% pdflatex test.tex
% biber test
% dann wieder pdflatex test.tex
% ba Datei Pfad anpassen


%T999-Beginn==================================================
\begin{document}

\title{T999} 
\author{Jan Herrmann}
\date{\today}
\maketitle

%\section{Test}
%Das ist meine LaTeX-Hausarbeit.
%\parencite{heimeshoff_certification_2024}
%testZitat
%\parencite{kim_planck_2024}


\tableofcontents
\newpage



%===================================================================================


\makeglossaries

% deine Einträge:
\newacronym{dll}{DLL}{Dynamic Linked Library – eine zur Laufzeit ladbare Programmbibliothek}
\newacronym{mysql}{MySQL}{Open-Source-Datenbankmanagementsystem}
\newacronym{sql}{SQL}{Structured Query Language – Sprache zur Verwaltung und Abfrage relationaler Datenbanken}
\newacronym{cs}{C\#}{Objektorientierte Programmiersprache auf der .NET-Plattform}
\newacronym{enum}{Enum}{Enumeration – ein Datentyp für benannte Konstanten, z.\,B. Fehlercodes}
\newacronym{logger}{Logger}{Komponente zur Protokollierung von Ereignissen im Programmablauf}
\newacronym{di}{DI}{Dependency Injection – Entwurfsmuster zur Injektion von Abhängigkeiten von außen}
\newacronym{integtest}{Integrationstest}{Test, bei dem mehrere Komponenten gemeinsam geprüft werden}
\newacronym{unittest}{Unit-Test}{Test einer einzelnen Codeeinheit isoliert von anderen Komponenten}
\newacronym{docker}{Docker}{Plattform zur Containerisierung von Anwendungen}
\newacronym{yaml}{YAML}{„YAML Ain’t Markup Language“ – menschenlesbares Konfigurationsformat}
\newacronym{connector}{Connector}{Schnittstelle, die die Kommunikation zwischen Anwendung und Datenbank ermöglicht}
\newacronym{interface}{Interface}{Vertragsschnittstelle in der Objektorientierung, die Methoden nur deklariert}
\newacronym{loggerintf}{Logger-Interface}{Abstraktes Interface für Logging, das per DI eingespeist wird}

%–– Im Dokument dann an der Stelle, an der du dein Abkürzungsverzeichnis haben willst ––
\printglossary[type=\acronymtype,title=Abkürzungsverzeichnis]


\end{description}

\newpage

\section{Einleitung}

    \needspace{4\baselineskip}
    \subsection{Motivation}
    Die Entwicklung einer eigenständigen DLL für den Datenbankzugriff bietet in modernen Softwaresystemen gleich mehrere entscheidende Vorteile. 
    Erstens schafft sie eine klare Trennung von Infrastruktur- und Geschäftslogik, indem sämtliche Verbindungsdetails, Fehlerbehandlung und Transaktionssteuerung an einem zentralen Ort 
    gekapselt werden. Anstatt in jedem Modul oder Service redundanten Code für Connection-Strings, Retry-Mechanismen oder SQL-Exceptions zu pflegen, greift die Anwendungs-Logik nur noch 
    über eine wohl definierte Schnittstelle auf die DLL zu. Dieses Separation-of-Concerns-Prinzip fördert nicht nur die Lesbarkeit und Wartbarkeit des Codes, sondern beschleunigt auch die 
    Einarbeitung neuer Teammitglieder.

    Zweitens ermöglicht eine modulare DB-Connector-Bibliothek die Wiederverwendbarkeit über unterschiedliche Projekte hinweg. Ob Web-API, Desktop-Anwendung oder Microservice-Architektur, 
    alle Consumers beziehen ihre Datenbankfunktionen aus derselben DLL. Bei Aktualisierungen, etwa wenn auf eine neue SQL-Bibliothek umgestellt oder Connection-Pooling optimiert werden soll, 
    genügt ein Austausch der DLL ohne Änderung an den Verbraucherprojekten. So lässt sich Validierung, Logging oder Performance-Tuning einheitlich implementieren und regressionsfrei einführen.
    
    Schließlich erhöht die Auslagerung in eine DLL die Testbarkeit enorm: In Unit- und Integrationstests kann die Datenbankzugriffsschicht gezielt gemockt oder gegen eine In-Memory-Datenbank 
    ausgetauscht werden, ohne tief in die Business-Logik eingreifen zu müssen. Auch in Continuous-Integration-Pipelines und Container-Umgebungen lässt sich 
    die DB-Connector-DLL isoliert versionieren, verteilen und überwachen. Gerade im Rahmen eines dualen Studiums, in dem neben technischer Exzellenz auch Best Practices der Team- und 
    Prozessarbeit vermittelt werden, leistet dieses Architekturpattern einen wertvollen Beitrag zur praxisnahen und skalierbaren Softwareentwicklung. \parencite{broy_Grundlagen_2019}.
    
    
    \needspace{5\baselineskip}    
    \subsection{Problemstellung und Ziel}
    In vielen unserer Anwendungen wiederholt sich der gleiche, plattformabhängige Boilerplate-Code für den Datenbankzugriff: Verbindungsaufbau, Parameter­zuweisung, 
    Fehler­behandlung, Transaktions­management und das Schließen von Verbindungen werden immer wieder neu implementiert. Das führt nicht nur zu erheblicher Redundanz, 
    sondern erschwert auch die zentrale Pflege von Änderungen – etwa beim Umstieg auf neue Treiber, geänderte Sicherheits­richtlinien oder optimierte Konfigurations­parameter. 
    Außerdem ist das Testen einzelner Komponenten durch fehlende Schnitt­stellen zur Mock-Erzeugung kompliziert und fehleranfällig.

    Vor diesem Hintergrund soll eine dynamische Bibliothek (DLL) entstehen, die sämtliche wiederkehrenden Aufgaben rund um den Datenbankzugriff in einer klaren, 
    wohlabgrenzten Schnittstelle bündelt. Die DLL übernimmt

    \begin{itemize}
        \item das Einlesen und Validierenvon Verbindungsparametern
        
        \item das Öffnen und Schließen von Verbindungen
        
        \item das Erzeugen und Ausführen von Befehlen inklusive Transaktionsunterstützung
        
        \item eine einheitliche Fehlerrückmeldung und Exception Klassenhierarchie

        \item die Integration mit Logging Frameworks

        \item die einfache Austauschbarkeit unterschiedlicher Datenabnkanbieter

    \end{itemize}

    Ziel ist es, eine zentrale, plattformunabhängige Komponente zur Verfügung zu stellen, die einfach und schnell in Projekte eingebunden werden kann und dank 
    eines Interfaces leicht mocked bzw. getestet werden kann. Durch die Kapselung der Infrastruktur in einer DLL reduzieren wir den Wartungsaufwand auf genau eine Stelle: 
    Neue Anforderungen, Security-Patches oder Performance-Optimierungen werden künftig nur noch in der Bibliothek umgesetzt und stehen damit sofort in allen Anwendungen zur Verfügung. 
    Zudem erleichtert die klare Trennung zwischen Geschäftslogik und Datenbankzugriff das Refactoring und steigert nachhaltig die Qualität und Zuverlässigkeit unserer Software.

    \needspace{5\baselineskip}
    \subsection{Zielsetzung und Projektbeschreibung}
        Ziel dieser Arbeit ist die Entwicklung einer wiederverwendbaren Verbindungsbibliothek in Form einer DLL für den Zugriff auf eine MySQL-Datenbank mit der Programmiersprache \csharp.
        Die Bibliothek soll grundlegende Funktionen wie den Aufbau und die Schließung von Datenbankverbindungen, die Ausführung von SQL-Abfragen (SELECT, INSERT, UPDATE, DELETE)
        sowie eine strukturierte Fehlerbehandlung kapseln. Besonderer Wert wird dabei auf eine saubere Trennung zwischen Anwendungslogik und Datenbankzugriff gelegt, 
        um die Wartbarkeit, Wiederverwendbarkeit und Testbarkeit des Codes zu verbessern.

        Das Projekt wird im Rahmen des dualen Studiums an der DHBW Stuttgart umgesetzt und verbindet theoretische Inhalte aus der Hochschulausbildung mit praxisorientierter Softwareentwicklung.
        Die entwickelte DLL soll so konzipiert sein, dass sie einfach in andere Anwendungen eingebunden werden kann und über eine einheitliche Schnittstelle angesprochen wird. 
        Ergänzend werden Unit- und Integrationstests durchgeführt, unter anderem mit Docker-Containern, um die Funktionalität in realitätsnahen Szenarien sicherzustellen.

%=================================================================================================================================================================================================

%Quelle =  Logische und Methodische Grundlagen der Programm- und Systementwicklung 
%           Datenstrukturen, funktionale, sequenzielle und objektorientierte Programmierung - Unter Mitarbeit von Alexander Malkis

% Für DLL brauche ich noch eine Quelle

\needspace{5\baselineskip}
\section{Grundlagen der Softwareentwicklung}

    \needspace{5\baselineskip}
    \subsection{Objektorientierte Programmierung}
        Die objektorientierte Programmierung (OOP) ist ein zentrales Konzept in der modernen Softwareentwicklung. 
        Sie beruht auf der Idee, Programme aus modularen Einheiten, sogenannten Objekten, aufzubauen. Diese Objekte basieren auf Klassen, die als Baupläne dienen. 
        
        Klassen definieren die Attribute und die Methoden, welche ihre Objekte besitzen. Eine Methode ist dabei eine Funktion innerhalb der Klasse, 
        die bestimmte Aktionen ausführt und den Zustand des Objekts verändern kann. 
        Ein wesentliches Merkmal der OOP ist die Vererbung. Sie erlaubt es, dass Klassen die Attribute und Methoden anderer Klassen übernehmen,
        wodurch Code wiederverwendet und strukturiert erweitert werden kann. Interfaces spielen ebenfalls eine wichtige Rolle, indem sie die Struktur und das Verhalten festlegen,
        das eine Klasse bereitstellen muss, ohne konkrete Implementierungen vorzugeben. 
        
        Fehlerbehandlung erfolgt in der OOP häufig über sogenannte Exceptions.
        Statt Fehlercodes zurückzugeben, werfen Methoden bei Problemen Ausnahmen, die dann gezielt behandelt werden können.
        Eine weitere hilfreiche Spracheigenschaft sind Enumerationen (Enums), die eine fest definierte Menge von Werten beschreiben, etwa Statuscodes und so die Lesbarkeit und Wartbarkeit
        des Codes erhöhen.
        
        \parencite{broy_grundlagen_2019}

    \needspace{5\baselineskip}
    \subsection{Dynamic Linked Library}
        Eine Dynamic Linked Library (DLL) ist eine Sammlung von Funktionen, die nicht direkt in das Hauptprogramm eingebunden werden, sondern bei Bedarf zur Laufzeit geladen werden. 
        Das hat den Vorteil, dass Programmteile modular ausgelagert und mehrfach verwendet werden können, ohne dass der Code dupliziert werden muss.

        DLLs werden häufig verwendet, um gemeinsame Funktionalität wie Datenbankzugriffe, mathematische Berechnungen oder Hardware-Kommunikation bereitzustellen. 
        In \csharp werden DLLs durch separate Projekte erstellt, die öffentliche Klassen und Methoden enthalten. 
        Diese Bibliotheken können dann in andere Projekte eingebunden und wie gewöhnliche Komponenten verwendet werden.

        Die Vorteile einer DLL liegen in ihrer Wiederverwendbarkeit, Modularität und Wartbarkeit. 
        Mehrere Programme können auf dieselbe DLL zugreifen, was Speicher spart und die Pflege erleichtert, da Änderungen nur an einer zentralen Stelle erfolgen müssen.
    
    \needspace{5\baselineskip}
    \subsection{Modellierung}
        Die Modellierung ist ein zentrales Element in der Softwareentwicklung, da sie hilft, komplexe Systeme strukturiert darzustellen, zu analysieren und zu planen. 
        Besonders in der objektorientierten Programmierung ist die visuelle Darstellung von Klassen, Beziehungen und Abläufen essenziell für das Verständnis und die Kommunikation 
        innerhalb eines Teams.

        Ein häufig verwendetes Werkzeug ist das Klassendiagramm. Es gehört zur Unified Modeling Language (UML) und stellt die Struktur eines Softwaresystems grafisch dar. 
        In einem Klassendiagramm werden Klassen mit ihren Attributen und Methoden dargestellt, ebenso wie die Beziehungen zwischen ihnen. 
        Dazu zählen Assoziationen (z.B. eine Klasse verwendet eine andere), Vererbungen (eine Klasse erbt von einer anderen) oder Aggregationen und Kompositionen (eine Klasse besteht aus anderen). 
        Klassendiagramme ermöglichen es, die logische Architektur eines Systems übersichtlich darzustellen, 
        bevor mit der eigentlichen Implementierung begonnen wird. Sie dienen sowohl der Dokumentation als auch der Kommunikation im Projektteam.

        Ein weiteres wichtiges Modellierungswerkzeug ist das Aktivitätsdiagramm. 
        Es beschreibt den Ablauf eines Prozesses oder eines bestimmten Anwendungsfalls in Form eines Flussdiagramms. 
        Dabei werden verschiedene Aktivitäten, Entscheidungswege, Verzweigungen und parallele Abläufe grafisch dargestellt. 
        Aktivitätsdiagramme eignen sich besonders gut, um Geschäftsprozesse, Programmabläufe oder Algorithmen verständlich abzubilden. 
        In der Softwareentwicklung wird das Aktivitätsdiagramm häufig eingesetzt, um komplexe Verhaltensweisen, wie etwa den Verbindungsaufbau zu einer Datenbank 
        oder eine Benutzerinteraktion mit dem System, detailliert zu analysieren.

        Durch die Verwendung solcher Modellierungswerkzeuge lassen sich Anforderungen klarer formulieren, 
        Entwurfsentscheidungen fundierter treffen und potenzielle Fehlerquellen bereits in der Planungsphase erkennen. 
        Die Modellierung bildet somit eine wichtige Brücke zwischen der konzeptionellen Planung und der technischen Umsetzung von Softwaresystemen.

    \needspace{5\baselineskip}
    \subsection{Speicherverwaltung}
        Ein grundlegendes Thema in der Softwareentwicklung, insbesondere in der System- und Embedded-Programmierung, ist der Umgang mit Speicher.
        Die effiziente Verwaltung von Speicherressourcen ist entscheidend für die Leistungsfähigkeit und Stabilität eines Programms. 
        In vielen Programmiersprachen wie C spielt dabei der direkte Zugriff auf Speicher durch sogenannte Pointer eine zentrale Rolle.

        Pointer (Zeiger) sind Variablen, die Speicheradressen enthalten und dadurch auf bestimmte Speicherbereiche verweisen können. 
        Sie ermöglichen unter anderem die dynamische Speicherreservierung sowie den Zugriff auf Arrays oder Strukturen. 
        Durch diese Flexibilität sind sie in der Low-Level-Programmierung unverzichtbar, erfordern jedoch ein genaues Verständnis des zugrundeliegenden Speichermodells.

        In Sprachen wie C erfolgt die Speicherverwaltung manuell. Das bedeutet, dass der benötigte Speicher explizit durch den Entwickler angefordert  
        und wieder freigegeben werden muss. Eine fehlerhafte Handhabung kann dabei zu Speicherlecks, Zugriffsfehlern oder Instabilitäten führen. 
        Daher erfordert die manuelle Speicherverwaltung ein hohes Maß an Sorgfalt und technischem Verständnis.

        Die Fähigkeit, Speicher effizient und sicher zu verwalten, bildet eine wichtige Grundlage für das Entwickeln performanter und zuverlässiger Software, 
        insbesondere im Kontext ressourcenbeschränkter Systeme wie Mikrocontroller oder eingebetteten Geräten.
    
    \needspace{5\baselineskip}
    \subsection{Grundlagen von Datenbanken}
        Datenbanken spielen eine zentrale Rolle in der heutigen Softwareentwicklung, insbesondere wenn es darum geht, Informationen dauerhaft, strukturiert und zuverlässig zu speichern. 
        Sie bilden das Rückgrat vieler Anwendungen, sei es in der Benutzerverwaltung, der Protokollierung von Prozessen oder der Speicherung geschäftsrelevanter Daten. 
        In dieser Arbeit steht der Zugriff auf relationale Datenbanken im Fokus, insbesondere in Kombination mit einer modularen und wiederverwendbaren Anbindung 
        über eine DLL.

        \needspace{5\baselineskip}
        \textbf{Relationale Datenbanken}

        Relationale Datenbanken gehören zu den am weitesten verbreiteten Datenbankmodellen. Ihre Grundlage bildet das relationale Datenbankmodell, das auf der mathematischen Mengenlehre basiert. 
        In relationalen Datenbanken werden Daten in Tabellen gespeichert, die aus Spalten (Attributen) und Zeilen (Datensätzen) bestehen. 
        Jede Zeile entspricht dabei einem Datensatz mit genau einem Wert pro Spalte.

        Ein wesentliches Merkmal relationaler Datenbanken ist die Verwendung von Schlüsseln zur eindeutigen Identifizierung und Verknüpfung von Daten. 
        Der Primärschlüssel identifiziert jeden Datensatz innerhalb einer Tabelle eindeutig. Fremdschlüssel hingegen stellen Beziehungen zwischen verschiedenen Tabellen her und ermöglichen es, 
        Daten logisch miteinander zu verbinden, ohne sie zu duplizieren. So kann beispielsweise eine Benutzer-ID als Fremdschlüssel in einer Tabelle für Logeinträge verwendet werden, 
        um den Zusammenhang zwischen Nutzer und Aktion herzustellen. Diese Struktur sorgt für Datenkonsistenz und fördert ein normalisiertes, redundanzfreies Datenmodell.

        Relationale Datenbanksysteme wie MySQL, PostgreSQL oder Microsoft SQL Server bieten darüber hinaus zahlreiche Funktionen zur Datenhaltung, Sicherung, Wiederherstellung und Abfrageoptimierung. 
        Transaktionen ermöglichen es, mehrere Datenbankoperationen logisch zusammenzufassen und im Fehlerfall rückgängig zu machen, 
        was insbesondere in sicherheitskritischen Anwendungen von großer Bedeutung ist.

        \needspace{5\baselineskip}
        \textbf{Aufbau von Tabellen und Schlüsselkonzepte}

        Beim Aufbau relationaler Datenbanktabellen müssen neben der inhaltlichen Struktur auch technische Aspekte berücksichtigt werden. 
        Jede Spalte einer Tabelle besitzt einen spezifischen Datentyp (z.B. Ganzzahlen, Zeichenketten oder Datumswerte), der definiert, welche Art von Informationen dort gespeichert werden können. 
        Ergänzend dazu können Einschränkungen wie „nicht leer“, „eindeutig“ oder „Standardwert“ definiert werden, um die Datenqualität zu sichern.

        Die Definition und Pflege von Primär- und Fremdschlüsseln ist essenziell für die referenzielle Integrität innerhalb des Datenbankschemas. 
        Durch Mechanismen wie das kaskadierende Löschen oder Aktualisieren lassen sich Inkonsistenzen vermeiden und ein konsistenter Datenbestand sicherstellen.

        Ein durchdachtes Datenbankdesign ist besonders in komplexen Softwaresystemen von zentraler Bedeutung. 
        Es hilft dabei, die Wartbarkeit zu erhöhen, die Erweiterbarkeit zu erleichtern und die Fehleranfälligkeit zu reduzieren. 
        Visuelle Hilfsmittel wie Entity-Relationship-Diagramme (ER-Diagramme) oder UML-Klassendiagramme unterstützen diesen Entwurfsprozess.
        SQL-Befehle

        Die Interaktion mit relationalen Datenbanken erfolgt in der Regel über die strukturierte Abfragesprache SQL (Structured Query Language). 
        SQL ist ein weltweit etablierter Standard und erlaubt sowohl die Definition der Datenstruktur als auch das Bearbeiten und Abfragen von Daten.

        Der Einsatz von SQL-Befehlen erlaubt es, gezielt auf einzelne Daten zuzugreifen, komplexe Zusammenhänge abzubilden und verschiedenste Operationen auf effiziente Weise durchzuführen. 
        Eine saubere Abgrenzung von Anwendungs- und Datenbanklogik, wie sie in dieser Arbeit durch die Nutzung einer DLL erfolgt, sorgt dabei für ein klares und wartbares Systemdesign.
        Bedeutung im Kontext der Anwendung

        Im Rahmen dieser Arbeit wird eine MySQL-Datenbank eingesetzt, auf die über eine eigens entwickelte \csharp-Bibliothek zugegriffen wird. 
        Diese Bibliothek kapselt alle Datenbankzugriffe in Form einer wiederverwendbaren DLL und stellt Methoden für das Öffnen und Schließen von Verbindungen, 
        die Ausführung von SQL-Abfragen sowie die Fehlerbehandlung bereit.

        Ein zentraler Aspekt dabei ist die Trennung von Datenzugriff und Anwendungslogik. Durch die Auslagerung des Datenbankzugriffs in eine separate Komponente wird die Wartbarkeit erhöht, 
        die Testbarkeit verbessert und die Wiederverwendbarkeit gewährleistet. Die klare Struktur der Datenbanktabellen, die Verwendung von Schlüsseln zur Sicherung der Integrität 
        sowie der gezielte Einsatz von SQL ermöglichen eine performante und robuste Datenhaltung, wie sie auch in produktiven Anwendungen in der Industrie üblich ist.

    \needspace{5\baselineskip}
    \subsection{Grundlagen Eingebetteter Systeme}
        Was ist ein Embedded System
        Was ist ein Debugger
        Programmiersprache C in Embedded Systemen
        Grundlagen zur Speicherverwaltung
        Zugriff auf Hardware
        Entwicklung mit dem Debugger


%=================================================================================================================================================================================================
\needspace{5\baselineskip}
\section{Vorgehensweise bei der Softwareentwicklung}

    \needspace{5\baselineskip}
    \subsection{Zielsetzung}
    Zu Beginn eines Softwareentwicklungsprozesses steht die präzise Ermittlung und Beschreibung der Anforderungen an das System.
     Diese umfassen sowohl funktionale als auch nicht-funktionale Anforderungen. Die Zielsetzung in dieser Phase besteht darin, alle relevanten Anforderungsziele, 
     Erwartungen der Nutzer, Erfolgskriterien und Rahmenbedingungen festzuhalten und im Idealfall zu formalisieren.

    Ein zentrales Ziel ist die Erstellung einer Anforderungsspezifikation, die als vertragliche Grundlage zwischen Auftraggeber und Auftragnehmer dient. 
    Die Spezifikation definiert, was ein System leisten soll, und bildet die Basis für Entwurfsentscheidungen, Verifikation, Validierung und letztlich für die Qualitätssicherung.
    
    Dabei wird besonderes Augenmerk auf die Vollständigkeit, Eindeutigkeit und Prüfbarkeit der Anforderungen gelegt. 
    Die so dokumentierten Ziele ermöglichen es, die spätere Implementierung zu bewerten und den Grad der Zielerreichung objektiv zu überprüfen
    
    \needspace{5\baselineskip}
    \subsection{Analyse}
    Im Analyseeschritt steht die Frage im Vordergrund, wie sich die in der Anforderungsspezifikation beschriebenen fachlichen und technischen Anforderungen zu einem tragfähigen 
    Architekturentwurf verdichten lassen. Dabei skizziert man zunächst eine grobe Schichtenarchitektur, in der typische Funktionsbereiche, wie etwa Präsentation, Geschäftslogik 
    und Datenzugriff, klar voneinander getrennt werden. Diese erste Zerlegung erlaubt es, Verantwortlichkeiten eindeutig zuzuordnen und spätere Änderungsauswirkungen bereits auf 
    konzeptioneller Ebene abzuschätzen.

    Anschließend erfolgt die Auswahl bewährter Entwurfsmuster, um wiederkehrende Probleme systematisch zu lösen und Konsistenz im gesamten System zu gewährleisten. So kommt zum Beispiel 
    das „Data Access Object“-Muster (DAO) zum Einsatz, um die Datenbankzugriffe von der Geschäftslogik zu entkoppeln, während das Schichtenmuster die Kommunikation zwischen Ober- 
    und Unterschichten regelt. Auch Aspekt­orientierung oder Dependency Injection können frühzeitig integriert werden, um Querschnitts­belange wie Logging, Transaktions­management oder 
    Sicherheit lose und doch zentral gesteuert abzubilden.

    Ein wesentlicher Teil der Analyse ist zudem die Definition klarer Schnittstellen zwischen den Komponenten. Hier wird festgelegt, welche Methoden, Datentypen und Protokolle 
    erforderlich sind, um die einzelnen Subsysteme miteinander zu verbinden, ohne deren Implementierungsdetails preiszugeben. Dieses Interface-Design legt den Grundstein für 
    Parallel­entwicklungen in agilen Teams und ermöglicht schon sehr früh frühe Tests von Mock-Komponenten oder Prototypen.

    Schließlich fließen in der Analyse auch nicht-funktionale Anforderungen wie Performanz, Skalierbarkeit oder Betriebssicherheit in die Architektur­entscheidungen ein. 
    Schon in dieser frühen Phase wird geprüft, ob beispielsweise eine Microservices- oder eine monolithische Deployment­strategie besser geeignet ist 
    und welche Infrastruktur­komponenten (Container, Messaging­systeme, Caching-Layer) erforderlich sein werden. Durch diese methodisch saubere Vorarbeit in der Analyse­phase 
    entsteht eine flexible, wartbare und erweiterbare Systemarchitektur, auf die alle nachfolgenden Entwurfs- und Implementierungsschritte aufbauen können
        
    \needspace{5\baselineskip}
    \subsection{Entwurf}

   Für die Implementierung wird zwischen zwei Stufen unterschieden: Zunäc hst wählt man auf einer hohen Abstraktionsebene passende Algorithmen und Datenstrukturen aus 
   und modelliert diese formal, um ihre Korrektheit und Effizienz verifizieren zu können. Darauf aufbauend erfolgt die konkrete Codierung in einer Programmiersprache und 
   gegebenenfalls eine Optimierung, um sie auf einer bestimmten Ausführungsplattform performant zum Laufen zu bringen.

.
    \needspace{5\baselineskip}
    \textbf{1. Abstrakte Implementierung}
    In diesem Schritt wird das Programm „auf hoher Abstraktionsebene“ beschrieben. Man legt fest, welche Datenstrukturen (z. B. Listen, Bäume, Maps) und Algorithmen 
    (z. B. Sortier- oder Suchverfahren) zum Einsatz kommen. Diese Spezifikation ist eng mit den Entwurfsspezifikationen verknüpft und erlaubt eine formale Verifikation, 
    etwa durch Ableiten von Korrektheitsbeweisen oder Bestimmen der Laufzeitkomplexität.
    
    \needspace{5\baselineskip}
    \textbf{2. Verifikation (auf der abstrakten Ebene)}

    Die abstrakten Implementierungen werden gegen ihre Spezifikationen geprüft. Hierzu nutzt man formale Methoden wie:
        
    Beweis von Invarianten und Korrektheit mittels Induktion oder Fixpunktargumenten
        
    Analyse der Terminierung und Ressourcenabschätzung

    Ziel ist, schon vor der eigentlichen Programmierung Fehler im Design aufzudecken und zu beheben.
    
    \needspace{5\baselineskip}
    \textbf{3. Konkrete Implementierung}
    
    Nach erfolgreicher Verifikation vervollständigt man den Code in einer spezifischen Programmiersprache. Dabei werden Details wie Speicherverwaltung, 
    Ein-/Ausgabe-Schnittstellen oder Sprachkonstrukte (z. B. Rekursion vs. Schleifen) berücksichtigt und oft optimiert, um auf der Zielplattform bestmögliche Performance zu erzielen.

    \needspace{5\baselineskip}
    \textbf{4. Verifikation (auf der konkreten Ebene)}
    
    Abschließend wird überprüft, dass die konkrete Implementierung die abstrakte Spezifikation tatsächlich erfüllt. Dies geschieht typischerweise durch Tests, statische Analysen 
    oder erneut formale Beweise (z. B. Hoare-Logik oder Model Checking).

    Dieser mehrstufige Ansatz, abstrakte Modellierung und Verifikation, gefolgt von konkreter Umsetzung und abschließender Prüfung, stellt sicher, dass bereits frühzeitig die 
    konzeptionelle Korrektheit gewährleistet ist und spätere Optimierungen die funktionale Korrektheit nicht gefährden 
    
    \needspace{5\baselineskip}
    \subsection{Umsetzung}
        Unit Tests und Integrationstests
        Dockerbasierter Testaufbau für MySQL



%========Verbindungsbiblothek=======================================================
%===================================================================================
    
    \needspace{5\baselineskip}
    \section{Verbindungsbibliothek}
    \subsection{Anfordungen}
        \textbf{Fachliche Anforderungen}    % was muss die DLL leisten
        \begin{itemize}
            \item Die Bibliothek muss es einem Anwender ermöglichen, sich mit einer Datenbank zu verbinden und diese Verbindung auch wieder zu trennen.

            \item Sie soll es erlauben, Datenbank-Abfragen auszuführen und die Ergebnisse als Tabellen darzustellen.

            \item Sie muss Befehle wie „Daten einfügen“, „aktualisieren“ oder „löschen“ unterstützen.

            \item Bei jeder Aktion soll klar zurückgemeldet werden, ob sie geklappt hat oder welcher Fehler aufgetreten ist.
        \end{itemize}


        \textbf{Technische Anforderungen}   % 
        \begin{itemize}

            \item Konfigurationsparameter müssen wahlweise über Connection-String oder ein stark typisiertes Konfigurationsobjekt übergeben werden können.

            \item Die Bibliothek soll sich per Dependency Injection einbinden lassen.

            \item Öffentliche APIs müssen XML-Dokumentationskommentare besitzen, damit automatisch Intellisense-Hilfe und Referenz-Dokumentation erzeugt werden kann.

            \item Transaktionen (BeginTransaction / Commit / Rollback) müssen unterstützt werden.
          
        \end{itemize}

        \textbf{Nichtfunktionale Anforderungen}

        \begin{itemize}
            \item \emph{Wartbarkeit}: Saubere Trennung von Schnittstelle und Implementierung, um Erweiterungen einfach zu realisieren.

            \item \emph{Portierbarkeit}: Die DLL soll auf allen .NET-Implementierungen (z.\,B. .NET Core, .NET 5+) lauffähig sein.

            \item \emph{Zuverlässigkeit}: Einheitliches Fehler- und Ausnahme­handling mit klar definierten Rückgabecodes.

            \item \emph{Testbarkeit}: Alle Kernkomponenten müssen so entkoppelt sein, dass sie sich mit Unit- und Integrationstests vollständig abdecken lassen.
          \end{itemize}

    \subsection{Konzept}
        \textbf{Architekturübersicht}       % Module, Schichten Interfaces

        
        \textbf{Klassenstruktur}
        
        
        
        \textbf{Designentscheidungen}       % z.B. Dependency Injection, Logging, Exception Handling

    \subsection{Implementierung}
        \textbf{Zentrale Klassen und Methoden}
    
        \textbf{Wichtige Code Beispiele}        % Connection Aufbaue, Query Handling
        
        \textbf{Teststrategie}                  % Unittests, Integrationtests Mockingconnection



\printbibliography  % Literaturverzeichnis einfügen

\end{document}


%Quellen